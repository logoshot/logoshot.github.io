---
title: "mit6.s081 Lab 2021 Pgtbl"
date: 2021-11-13T21:26:18+08:00
draft: true
---

mit6s081的第三个lab，非常考验对于页表的理解，难度不小。从个人体验来讲，和前两个lab相比，难度上了一个档次。当然，这可能也源于我对虚存机制的理解还不够深入。而且，我虽然通过了lab的测试，但是心中仍存有诸多疑惑。

这里注意一下，本文针对的是2021版的课程实验，[2021版](https://pdos.csail.mit.edu/6.828/2021/labs/pgtbl.html)的pgtbl实验进行了改动，与[2020版](https://pdos.csail.mit.edu/6.828/2020/labs/pgtbl.html)不一样。

前两个小实验较为简单，根据实验给出hints，可以比较容易的做出，这里不再赘述。

第三个小实验是要检测哪些页被读写过了。检测的原理是基于在risc-v中，被读写过的页会在页表中被标记上PTE\_A标志位。因此只需要我们只需要遍历给定的页，对于每一个给定的页，根据页表的规则，找到相应表项，看看PTE\_A标志位即可。

核心思路看起来是蛮简单的，但是到实现的时候就会遇到不少麻烦。

第一，我一开始就疑惑于这个页对应的页表是哪一个页表。根据直觉，应该是当前进程的页表，也就是可以通过`myproc()->pagetable`访问到，实际上也确实是。但我总感觉哪里不踏实。

第二，题目的提示中特意提到，我们可以将检测的结果先保存在一个临时变量中，然后再使用`copyout`拷贝到用户的变量中。我一开始以为，题目给出这个提示是说明内核空间访问用户空间的变量存在问题，因此也需要把存页地址的数组`copyin`到内核，但是转念一想，如果内核空间不能访问用户空间的变量，那么`copyin`也是无法进行的。在实验成功后，我尝试直接对用户空间变量进行操作，发现会产生kerneltrap的panic，而且是在修改变量值的那一步，所以可以推断出内核不能修改用户空间的变量？

第三，`pgtbltest.c`中的测试`pgaccess()`的方式也让人有些疑惑。它是声明了大小为
$32*PGSIZE$的数组，而后改动数组中的值，就相当于读写了某个页。因此我自认为合理的推测`buf[0]`到`buf[PGSIZE-1]`属于第一个页，`buf[PGSIZE]`到`buf[PGSIZE*2-1]`属于第二个页，然而，经过测试发现并不是这样。`buf[4079]`属于第一页，`buf[4080]`属于第二页。？？？
